```{r setup, include=FALSE}
list.of.packages <- c("sp", "geosphere", "rgdal", "adehabitatHR", "foreach", "doParallel", "parallel", "beepr",
                      "tidyverse", "plyr", "knitr", "gridExtra", "lme4", "lmerTest",
                      "rasterVis", "Cairo", "ggmap", "scales", "maptools", "raster", "rgeos", "mgcv", "broom.mixed", 
                      "kableExtra", "jtools","metap", "fields", "viridis", "TeachingDemos", "latticeExtra", "Matching", 
                      "MuMIn", "tidylog", "rsq", "robustbase")

lapply(list.of.packages, require, character.only = T)
remove(list.of.packages, new.packages)
```



## Practical applications of function results 
We plot the maximum representativity value in a map, to check whether there's a spatial structure to the degree in which each colony can represent the entire species. Moreover, the representativity percentage will indicate how close our sample is of reaching this maximum representativity value

### Calculate distance to "geographic centre"

We want to see if there is a geographic structure in our data. One option is to check the effect of longitude, latitude and their interaction. Another choice is to generate a kernel of all the colony locations, calculate its centroid, and calculate the distance of each colony to this centroid. 

First we load the colony information, turn it into spatial object and transform to planar projection
```{r calculate GeoDistance1}
col_coordinatesK <- read.csv("data/colonies_info_for_kernel.csv")

mapa.i <- rgeos::gBuffer(rworldmap::getMap(resolution = "high"), width = 0)
mapa.i@proj4string <- CRS(projections$WGS84)
mapa.i <- spTransform(mapa.i, CRS(projections$EquidistConic))

col_coordinatesK %>% 
  filter(!is.na(Pop.Min)) %>% # remove colonies without pop.size
  ddply(~Radius100, summarize, Tot.pop = sum(Pop.Min)) %>% # sum pop.size of all colonies inside the radius ("population")
  full_join(col_coordinatesK, by = "Radius100") %>%  # merge the sum with the original dataset
  dplyr::select(-Tot.pop, -Sample.Size, -Pop.Min, -Pop.Max) -> col_points # remove all colonies that have not been sampled
  
coordinates(col_points) <- ~Longitude + Latitude
col_points@proj4string <- CRS(projections$WGS84)
col_points <- spTransform(col_points, CRS(projections$EquidistConic))
```

We now calculate 95% UD from kernel estimates (why 95%? think about it*), and their centroids, and plot them to see what we've done
* I've tried 50% and the 50UD and for CALBOR does not include at all colonies in iberia, so it's the centroid between azores and canary islands. For caldio doesn't really make a difference because colonies are sort of evenly spread
```{r calculate GeoDistance2, eval = FALSE}
UD_CB <- kernelUD(col_points[col_points$Species == "CALBOR",], h = 186000, grid = 500, extent = 1)
k95_CB <- getverticeshr(UD_CB, percent = 95)
CB_centroid <- rgeos::gCentroid(k95_CB)

UD_CD <- kernelUD(col_points[col_points$Species == "CALDIO",], h = 186000, grid = 500, extent = 1)
k95_CD <- getverticeshr(UD_CD, percent = 95)
CD_centroid <- rgeos::gCentroid(k95_CD)

UD_CE <- kernelUD(col_points[col_points$Species == "CALEDW",], h = 186000, grid = 500, extent = 4)
k95_CE <- getverticeshr(UD_CE, percent = 95)
CE_centroid <- rgeos::gCentroid(k95_CE)

plot(UD_CB, main = "C. borealis colonies") 
plot(col_points[col_points$Species == "CALBOR",], pch = 3, col = "white", add = T)
plot(k95_CB, border = "", add = T)
plot(CB_centroid, pch = 8, col = "red", add = T)
plot(mapa.i, border = "white", add = T)

plot(UD_CD, main = "C. diomedea colonies") 
plot(col_points[col_points$Species == "CALDIO",], pch = 3, col = "white", add = T)
plot(k95_CD, border = "red", add = T)
plot(CD_centroid, pch = 8, col = "red", add = T)
plot(mapa.i, border = "white", add = T)

plot(UD_CE, main = "C. edwardsii colonies") 
plot(col_points[col_points$Species == "CALEDW",], pch = 3, col = "white", add = T)
plot(k95_CE, border = "red", add = T)
plot(CE_centroid, pch = 8, col = "red", add = T)
plot(mapa.i, border = "white", add = T)
```

We use the gDistance function to calculate geographic distance from each sampled colony to the calculated geographic centroid of the population
```{r calculate GeoDistance3, eval = FALSE}
col_coordinates <- read.csv("data/colonies_info_100km.csv")
col_coordinates %>% 
  filter(!is.na(Sample.Size)) -> cols_for_model
coordinates(cols_for_model) <- ~ Longitude + Latitude
cols_for_model@proj4string <- CRS(projections$WGS84)
cols_for_model <- spTransform(cols_for_model, CRS(projections$EquidistConic))

distCB <- data.frame(Colony = cols_for_model[cols_for_model$Species == "CALBOR",]$SampledColony,
                     Species = "CALBOR",
                     GeoDistance = gDistance(cols_for_model[cols_for_model$Species == "CALBOR",], CB_centroid, byid = T)[1,])

distCD <- data.frame(Colony = cols_for_model[cols_for_model$Species == "CALDIO",]$SampledColony,
                     Species = "CALDIO",
                     GeoDistance = gDistance(cols_for_model[cols_for_model$Species == "CALDIO",], CD_centroid, byid = T)[1,])

distCE <- data.frame(Colony = cols_for_model[cols_for_model$Species == "CALEDW",]$SampledColony,
                     Species = "CALEDW",
                     GeoDistance = gDistance(cols_for_model[cols_for_model$Species == "CALEDW",], CE_centroid, byid = T)[1,])

GeoDistance <- rbind(distCB, distCD, distCE)

cols_for_model <- as.data.frame(cols_for_model)

names(cols_for_model)[4] <- "Colony"

cols_for_model <- full_join(cols_for_model, GeoDistance, by = c("Species", "Colony"))
```

### Calculate distance to "population" centre

The geographic centre of a population does't necessarily have to be the "ecological" center. We will now calculate the same kernel but "weighing" each colony by its pop. size, so as to calculate an "ecological" centre of the population (assuming more abundant colonies lie nearer to the "ecological centre")

First we generate a dataset to "trick" the kernel function to assign a weight to each colony according to its population size. This dataset will contain, with the colony coordinates, as many points as population size, for each colony. We then turn it into a (very large) spatial object, with as many points as pop.size at each colony. 
```{r calculate PopDistance1}
col_coordinatesK %>% 
  filter(!is.na(Pop.Min)) %>% # remove colonies without pop.size
  ddply(~Radius100, summarize, Tot.pop = sum(Pop.Min)) %>% # sum pop.size of all colonies inside the radius ("population")
  full_join(col_coordinatesK, by = "Radius100") %>%  # merge the sum with the original dataset
  as_tibble() %>%
  mutate(obs = purrr::map(Tot.pop, ~rep_len(1, .x))) %>% # add a vector to the tibble (1 colum with a vector in each row, a column of vectors) with an N equal to sample size (Tot.pop)
  unnest() %>% # un-nest: repeating each row as many times as elements in the vector in the column added above
  dplyr::select(-obs, -Tot.pop, -Sample.Size, -Pop.Min, -Pop.Max) -> col_points_weighted # remove unnecessary columns and assigning to col_points_weighted

coordinates(col_points_weighted) <- ~Longitude + Latitude
col_points_weighted@proj4string <- CRS(projections$WGS84)
col_points_weighted <- spTransform(col_points_weighted, CRS(projections$EquidistConic))
```

We now calculate the 95% UDs of these kernel estimates, which will take a long time because the datasets are larger, and their centroids (which will be shifted towards the largest colonies) and plot them
```{r calculate PopDistance2, eval = FALSE}
UD_CBw <- kernelUD(col_points_weighted[col_points_weighted$Species == "CALBOR",], h = 186000, grid = 500, extent = 1)
k95_CBw <- getverticeshr(UD_CBw, percent = 95)
CB_centroidw <- rgeos::gCentroid(k95_CBw)

UD_CDw <- kernelUD(col_points_weighted[col_points_weighted$Species == "CALDIO",], h = 186000, grid = 500, extent = 1)
k95_CDw <- getverticeshr(UD_CDw, percent = 95)
CD_centroidw <- rgeos::gCentroid(k95_CDw)

UD_CEw <- kernelUD(col_points_weighted[col_points_weighted$Species == "CALEDW",], h = 186000, grid = 500, extent = 4)
k95_CEw <- getverticeshr(UD_CEw, percent = 95)
CE_centroidw <- rgeos::gCentroid(k95_CEw)

plot(UD_CBw, main = "C. borealis colonies weighted") 
plot(col_points[col_points$Species == "CALBOR",], pch = 3, col = "white", add = T)
plot(k95_CBw, border = "red", add = T)
plot(CB_centroidw, pch = 8, col = "red", add = T)
plot(mapa.i, border = "white", add = T)

plot(UD_CDw, main = "C. diomedea colonies weighted") 
plot(col_points[col_points$Species == "CALDIO",], pch = 3, col = "white", add = T)
plot(k95_CDw, border = "red", add = T)
plot(CD_centroidw, pch = 8, col = "red", add = T)
plot(mapa.i, border = "white", add = T)

plot(UD_CEw, main = "C. edwardsii colonies") 
plot(col_points[col_points$Species == "CALEDW",], pch = 3, col = "white", add = T)
plot(k95_CEw, border = "red", add = T)
plot(CE_centroidw, pch = 8, col = "red", add = T)
plot(mapa.i, border = "white", add = T)
```

Finally we calculate the distance to the "Population center", using the same gDistance function, and merge it with the dataset of the sampled colonies. 
```{r calculate PopDistance3, eval = FALSE}
coordinates(cols_for_model) <- ~ Longitude + Latitude
cols_for_model@proj4string <- CRS(projections$EquidistConic)

distCB <- data.frame(Colony = cols_for_model[cols_for_model$Species == "CALBOR",]$Colony,
                     Species = "CALBOR",
                     PopDistance = gDistance(cols_for_model[cols_for_model$Species == "CALBOR",], CB_centroidw, byid = T)[1,])

distCD <- data.frame(Colony = cols_for_model[cols_for_model$Species == "CALDIO",]$Colony,
                     Species = "CALDIO",
                     PopDistance = gDistance(cols_for_model[cols_for_model$Species == "CALDIO",], CD_centroidw, byid = T)[1,])

distCE <- data.frame(Colony = cols_for_model[cols_for_model$Species == "CALEDW",]$Colony,
                     Species = "CALEDW",
                     PopDistance = gDistance(cols_for_model[cols_for_model$Species == "CALEDW",], CE_centroidw, byid = T)[1,])

PopDistance <- rbind(distCB, distCD, distCE)

cols_for_model <- as.data.frame(cols_for_model)

cols_for_model <- full_join(cols_for_model, PopDistance, by = c("Species", "Colony"))
```

### Prepare data for modelling
We now prepare the dataset, modifying covariates to make them more practical. We also remove Cape Verde colonies from the dataset since there are only two colonies and that's no good for a regression (we're using "Species" as factor)
```{r lmm1 }
# cols_for_model %>%
#   left_join(colony_boot_summary, by = "Colony") %>%
#   filter(!is.na(RepresentativeValue)) %>%
#   mutate(Pop.Size = Pop.Min*2) %>%
#   select(Asymptote, Species, Colony, Sample.Size, Pop.Size, PopDistance, GeoDistance, Longitude, Latitude) -> cols_for_model

# coordinates(cols_for_model) <- ~ Longitude + Latitude
# cols_for_model@proj4string <- CRS(projections$EquidistConic)
# cols_for_model <- spTransform(cols_for_model, CRS(projections$WGS84))
# cols_for_model <- as.data.frame(cols_for_model)
# 
# cols_for_model %>% 
#   mutate(LogSample.Size = log(Sample.Size), 
#          LogPop.Size = log(Pop.Size),
#          GeoDistanceKM = GeoDistance/1000, 
#          PopDistanceKM = PopDistance/1000) -> cols_for_model


# write.csv(cols_for_model, file = "modelling_dataset.csv")
# cols_for_model <- read.csv("modelling_dataset.csv")
cols_for_model %>% filter(Species != "CALEDW") -> cols_for_model2

```

### Visualise relationship between covariates and Representativeness

Now we visualize the linear effect of each covariate, and the correlations among them to check for colinearity
```{r lmm2}
ggplot(cols_for_model2, aes(PopDistanceKM, Asymptote)) + 
  geom_point(aes(col = Species)) + 
  geom_smooth(method = "lm", aes(col = Species)) + facet_wrap(~Species) + 
  scale_y_continuous(labels = percent, limits = c(0, 0.60))

ggplot(cols_for_model2, aes(GeoDistanceKM, Asymptote)) + 
  scale_y_continuous(labels = percent, limits = c(0, 0.60)) + 
  geom_point(aes(col = Species)) + 
  geom_smooth(method = "lm", aes(col = Species)) + facet_wrap(~Species)

ggplot(cols_for_model2, aes(Longitude, Asymptote)) + 
  geom_point(aes(col = Species)) + 
  geom_smooth(method = "lm", aes(col = Species)) + facet_wrap(~Species)

ggplot(cols_for_model2, aes(Latitude, Asymptote)) + 
  geom_point(aes(col = Species)) + 
  geom_smooth(method = "lm", aes(col = Species)) + facet_wrap(~Species)

ggplot(cols_for_model2, aes(LogSample.Size, Asymptote)) + 
  geom_point(aes(col = Species)) + 
  geom_smooth(method = "lm", aes(col = Species)) + facet_wrap(~Species)

ggplot(cols_for_model2, aes(LogPop.Size, Asymptote)) + 
  geom_point(aes(col = Species)) + 
  geom_smooth(method = "lm", aes(col = Species)) + facet_wrap(~Species)

plot(cols_for_model2[,8:13], panel = panel.smooth)
plot(cols_for_model2[cols_for_model$Species == "CALBOR",8:13], panel = panel.smooth)
plot(cols_for_model2[cols_for_model$Species == "CALDIO",8:13], panel = panel.smooth)
```

We see colinearity between distance to population centre and distance to geographic centre, unsurprisingly. This colinearity is mainly given by the CALDIO datapoints. We will take it into account, but still run first the full model with both covariates, although it can be substituted by Longitude:Latitude

After recommendation from coauthors we model separatedly CALBOR & CALDIO (effects might be different for each sp)
We are also going to use a robust estimation of SE and CI ("HC5"), from package `jtools` defined from functions of the package `sandwich`and following 
>Cribari-Neto F., Souza T.C., Vasconcellos, K.L.P. (2007), Inference under Heteroskedasticity and Leveraged Data. Communications in Statistics - >Theory and Methods,36, 1877-1888. Errata:37,3329-3330, 2008.

We've chosen this since we have few observations and as such we need a method for estimating SE that is robust to points with high leverage

### CALDIO: Run and diagnose the model 

#### Full model
Run full model, with Long*Lat, GeoDistance and PopDistance, all of them
```{r lmm3}
cols_for_model %>% filter(Species == "CALDIO") -> cd_for_model

mFull <- lm(Asymptote ~ Latitude*Longitude + PopDistanceKM + GeoDistanceKM + LogPop.Size + LogSample.Size, 
           data = cd_for_model, na.action = "na.fail")

par(mfrow = c(2,2))
plot(mFull)
par(mfrow = c(1,1))

jtools::summ(mFull, robust = "HC5", scale = T, confint = T, vifs = T)
plot_summs(mFull, scale = T, plot.distributions = F, rescale.distributions = T, model.names = c("Full model"), robust = "HC5")
```

This model doesn't seem bad (diagnostics are pretty good). However, the overall fit F test shows that there is no significant difference between the fit of this model and that of the intercept-only model. Also, there are very high VIF values for GeoDistance and PopDistance, which seems obvious since we saw earlier that they are quite correlated. We remove GeoDistance as we believe "spatial structure" can be captured accuratedly enough by Longitude and Latitude

#### First model
```{r lmm4}
m1 <- lm(Asymptote ~ Latitude*Longitude + PopDistanceKM + LogPop.Size + LogSample.Size, 
         data = cd_for_model, na.action = "na.fail")

par(mfrow = c(2,2))
plot(m1)
par(mfrow = c(1,1))

jtools::summ(m1, robust = "HC5", scale = T, confint = T, vifs = T)
plot_summs(m1, mFull, scale = T, plot.distributions = F, robust = "HC5", model.names = c("Model1", "Full model"))
```
Again, model diagnostics are good, but still not better fit than the null (intercept only). Still Longitude, Latitude and their interaction have a high VIF, so we remove the interaction


#### Second model
```{r lmm5}
m2 <- lm(Asymptote ~ Latitude + Longitude + PopDistanceKM + LogPop.Size + LogSample.Size, 
         data = cd_for_model, na.action = "na.fail")

par(mfrow = c(2,2))
plot(m2)
par(mfrow = c(1,1))

jtools::summ(m2, robust = "HC5", scale = T, confint = T, vifs = T)
plot_summs(m2, m1, mFull, scale = T, plot.distributions = F, robust = "HC5", model.names = c("Model2", "Model1", "Full model"))
```
Again, no significant improvement from the intercept-only model, although now distance to the "center of mass" is significant, although with a very small effect. We try and remove Latitude, which we know is not biologically relevant for this species, to see if it improves

#### Third model
```{r lmm6}
m3 <- lm(Asymptote ~ Longitude + PopDistanceKM + LogSample.Size + LogPop.Size, 
         data = cd_for_model, na.action = "na.fail")

par(mfrow = c(2,2)); plot(m3); par(mfrow = c(1,1))

jtools::summ(m3, robust = "HC5", scale = T, confint = T, vifs = T)
plot_summs(m3, m2, m1, mFull, scale = T, plot.distributions = F, robust = "HC5", 
           model.names = c("Model3", "Model2", "Model1", "Full model"), colors = "Set1")
```
Diagnostics are good, vifs are all under 2... all good. All p-value is significative for PopDistanceKM. If we check CI, those of PopDistanceKM and Longitude do not overlap 0. F value tells us this model is not a significant improvement over the intercept-only model. We will dredge it to see what covariates are retained. 

```{r lmm7}
d3 <- dredge(m3, trace = 2, beta = "sd")

d3 %>%
  kable(digits = 3) %>%
  kable_styling()

avg3 <- model.avg(d3, delta < 2, beta = "sd")
summary(avg3)
```
We see that indeed, the best model is the intercept-only one. However, the next 4 have a delta <2, so when we average them we see that the selected variables are Distance to the "mass center" of the population, Sample size and Longitude, with relative importances in that order. 

We rerun the model excluding LogPop.size as recommended by the dredge. However, leaving it in produces almost the same results but a worst fit (F-test and adjusted R^2)
#### Final model
```{r lmm8}
mFin <- lm(Asymptote ~ Longitude + PopDistanceKM + LogSample.Size, 
         data = cd_for_model, na.action = "na.fail")

par(mfrow = c(2,2)); plot(mFin); par(mfrow = c(1,1))

jtools::summ(mFin, robust = "HC5", scale = T, confint = T, vifs = T)
plot_summs(mFin, m3, mFull, scale = T, plot.distributions = F, rescale.distributions = T, robust = "HC5",
           model.names = c("Final Model", "Third model", "Full model"))
```


#### Visualise output of final model
So, to summarize: the factor "species" is not significant, the variable latitude and distance to population centre are, and sample size is "marginally" significant. Let's visualise these relationships: 

```{r lmm output2}
a <- ggplot(cd_for_model, aes(PopDistanceKM, Asymptote)) + 
  geom_smooth(method = "lm", col = "black") + 
  xlab("Distance to the species centre of mass (Km)") + 
  ylab("Species representativeness") + scale_y_continuous(labels = percent, limits = c(0, 0.60)) + 
  theme_classic() + 
  theme(axis.text = element_text(size = 13),
        axis.title = element_text(size = 16),
        legend.text = element_text(size = 13))

pdf("caldio_model.pdf", width = 8, height = 4)
a
dev.off()

# b <- ggplot(cd_for_model, aes(Longitude, Asymptote)) + 
#   geom_smooth(method = "lm", col = "gray30") + 
#   ylab("Species Representativeness") + scale_y_continuous(labels = percent, limits = c(0, 0.60)) + 
#   theme_classic()
# 
# c <- ggplot(cd_for_model, aes(LogSample.Size, Asymptote)) +
#   geom_smooth(method = "lm", col = "gray30") +
#   xlab("Sample Size") + ylab("Species Representativeness") + scale_y_continuous(labels = percent, limits = c(0, 0.60)) + 
#   theme_classic()
# 
# grid.arrange(a, b, c, ncol = 1)
```

### CALBOR: Run and diagnose the model 

#### Full model
We can't  run the full model because there would be more effects than observations (we run out of degrees of freedom), so we remove geoDistance (because it's highly correlated with PopDistance) and the interaction between Lon and Lat (as it usually generates high VIF values) and expect those two variables alone to capture properly any spatial structure
```{r lmm3}
cols_for_model %>% filter(Species == "CALBOR") -> cb_for_model

mFull <- lm(Asymptote ~ Longitude + Latitude + PopDistanceKM + LogPop.Size + LogSample.Size, 
           data = cb_for_model, na.action = "na.fail")

par(mfrow = c(2,2))
plot(mFull)
par(mfrow = c(1,1))

jtools::summ(mFull, robust = "HC5", scale = T, confint = T, vifs = T)
plot_summs(mFull, scale = T, plot.distributions = F, robust = "HC5", model.names = c("Full model"))
```
This model has a horrible fit (QQplot is very bad). Moreover, there are three VIF values (Longitude and Population distance) that are higher than desired. We remove first longitude and then PopDistance and see which model improves more. The better model removes Longitude and retains PopDistance, so we do that

#### First model
```{r lmm4}
m1 <- lm(Asymptote ~ Latitude + PopDistanceKM + LogPop.Size + LogSample.Size, 
         data = cb_for_model, na.action = "na.fail")

par(mfrow = c(2,2))
plot(m1)
par(mfrow = c(1,1))

jtools::summ(m1, robust = "HC5", scale = T, confint = T, vifs = T)
plot_summs(m1, mFull, scale = T, plot.distributions = F, robust = "HC5", model.names = c("Model1", "Full model"))
```
This improves diagnostics quite a lot, but still doesn't seem to perfrom better than the intercept-only model, and none of the effects are significant. Since we don't have any reason to remove any of the other variables first, we dredge to see which variables get selected. 

#### Dredge
```{r lmm7}
d1 <- dredge(m1, trace = 2, beta = "sd")

d1 %>%
  kable(digits = 3) %>%
  kable_styling()

avg <- model.avg(d1, delta < 2)
summary(avg)
```
We see that indeed, the best model is the intercept-only one. Only the next one has a deltaAIC < 2, and it only selects Latitude. We run the final model only with Latitude then: 

#### Final model
```{r lmm8}
mFin <- lm(Asymptote ~ Latitude, 
         data = cb_for_model, na.action = "na.fail")

par(mfrow = c(2,2)); plot(mFin); par(mfrow = c(1,1))

jtools::summ(mFin, robust = "HC5", scale = T, confint = T, vifs = F)
plot_summs(mFin, mFull, scale = T, plot.distributions = F, robust = "HC5", 
           model.names = c("Final Model", "Full model"))
```


#### Visualise output of final model
So, to summarize: the factor "species" is not significant, the variable latitude and distance to population centre are, and sample size is "marginally" significant. Let's visualise these relationships: 

```{r lmm output2}
b <- ggplot(cb_for_model, aes(Latitude, Asymptote)) + 
  geom_smooth(method = "lm", col = "black") + 
  xlab("Latitude") + 
  ylab("Species representativeness") + scale_y_continuous(labels = percent, limits = c(0, 0.60)) + 
  theme_classic() + 
  theme(axis.text = element_text(size = 13),
        axis.title = element_text(size = 16),
        legend.text = element_text(size = 13))

pdf("calbor_model.pdf", width = 8, height = 4)
b
dev.off()
```
